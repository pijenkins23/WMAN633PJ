det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
(ex * (1 - det))
return(sum(ts))
}
pear(fit)
hist(sims@t.star[, 1], xlab = 'chisq',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
hist(sims@t.star[, 1], xlab = 'chisq',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
hist(sims@t.star[, 1], xlab = 'chisq',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
View(sims)
states(fit)
predict?
predict(fit, type= "state")
predict(fir, type ="det")
predict(fit, type = "det")
predict(fit, type = "state")
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
# ex <- fitted(mod) #obs prob * expected count
exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - exabun * det) ^ 2 / # chi-square statistic
((ex *det) * (1 - det))
return(sum(ts))
}
pear(fit)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
# ex <- fitted(mod) #obs prob * expected count
exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - exabun * det) ^ 2 / # chi-square statistic
((exabun *det) * (1 - det))
return(sum(ts))
}
pear(fit)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
# exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ext) * (1 - det))
return(sum(ts))
}
pear(fit)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
# exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det))
return(sum(ts))
}
pear(fit)
sims
sims <- parboot(fit, pear, nsim = 100)
sims
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
# exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det))
return(sum(ts))
}
pear(fit)
plot(sims)
#2. Write a function that calculates the sum of squared Pearson residuals from a fitted model. This test
#statistic can be calculated as:
mod <- fit
ex <- fitted(mod)
View(ex)
det <- predict(mod, type = "det")
exabun <- predict(mod, type = "state")
View(exabun)
View(det)
obs <- getY(mod@data)
obs <- getY(mod@data)
View(obs)
exabun$Predicted*det$Predicted
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det))
((ex) * (1 - det))
((ex) * (1 - det$Predicted))
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
# exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)
str(ex)
((ex) * (1 - det$Predicted))
sum(ts)
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
View(ts)
sum(ts)
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
# exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - ex) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)
sims <- parboot(fit, pear, nsim = 100)
sims
plot(sims)
hist(sims@t.star[, 1], xlab = 'chisq',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
sims <- parboot(fit, pear, nsim = 1000)
sims
plot(sims)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
pear(fit)
pear(fit)
exP <- exabun$Predicted*det$Predicted
exP
exP
ex
pear(fit)
exP
pear(fit)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
#ex <- fitted(mod) #obs prob * expected count
exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - (exabun$Predicted*det$Predicted)) ^ 2 / # chi-square statistic
((exabun$Predicted*det$Predicted) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)  # 1025.856
y <- read.csv('sosp_nmix (2).csv')
head(y)
library(unmarked)
# converting count data into a matrix
# matrix format required by unmarkedFramePCount
sosp_mat <- as.matrix(y)
nmix_data <- unmarkedFramePCount(y = sosp_mat)
# Covariate s
##################
det_covs <- read.csv('p_covs_nmix (2).csv')
head(det_covs)
det_covs <- list(
time = data.frame(p_covs[, c('time.1', 'time.2')]),
sky = data.frame(sky.1 = factor(p_covs$sky.1),
sky.2 = factor(p_covs$sky.2))
)
site_covs <- read.csv('n_covs_nmix (2).csv')
head(site_covs)
site_covs$type <- factor(site_covs$type)
nmix_data <- unmarkedFramePCount(y = sosp_mat, # detection / non-detection
siteCovs = site_covs, # site-level covs
obsCovs = det_covs)
#Fit an N-mixture model that assumes abundance is a function of wetland size and type, and detection
#probability is a function of sky and time (5 points).
fit <- pcount(formula = ~ time + sky ~ size + type,
data = nmix_data, K = 100)
fit
#2. Write a function that calculates the sum of squared Pearson residuals from a fitted model. This test
#statistic can be calculated as:
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
#ex <- fitted(mod) #obs prob * expected count
exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - (exabun$Predicted*det$Predicted)) ^ 2 / # chi-square statistic
((exabun$Predicted*det$Predicted) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
mod
ex
fitted(mod)
det
det_covs$time[1, ]
det_covs$sky[1, ]
mod
coef(mod)
plogis(coef(mod)[4] + det_covs$time[1, 1] * coef(mod)[5])
det[1, ]
plogis(coef(mod)[4] + det_covs$time[1, 2] * coef(mod)[5] + coef(mod)[6])
det[1:4, ]
det_covs$sky[2, ]
plogis(coef(mod)[4] + det_covs$time[2, 1] * coef(mod)[5])
det <- predict(mod, type = "det")
det <- as.matrix(det$Predicted, byrow = TRUE)
det
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
det
View(det)
View(det)
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
det <- as.matrix(det$Predicted, byrow = TRUE)
detm <- as.matrix(det$Predicted, byrow = TRUE)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
as.matrix(det$Predicted, byrow = TRUE)
y <- read.csv('sosp_nmix (2).csv')
head(y)
library(unmarked)
# converting count data into a matrix
# matrix format required by unmarkedFramePCount
sosp_mat <- as.matrix(y)
nmix_data <- unmarkedFramePCount(y = sosp_mat)
# Covariate s
##################
det_covs <- read.csv('p_covs_nmix (2).csv')
head(det_covs)
det_covs <- list(
time = data.frame(p_covs[, c('time.1', 'time.2')]),
sky = data.frame(sky.1 = factor(p_covs$sky.1),
sky.2 = factor(p_covs$sky.2))
)
site_covs <- read.csv('n_covs_nmix (2).csv')
head(site_covs)
site_covs$type <- factor(site_covs$type)
nmix_data <- unmarkedFramePCount(y = sosp_mat, # detection / non-detection
siteCovs = site_covs, # site-level covs
obsCovs = det_covs)
#Fit an N-mixture model that assumes abundance is a function of wetland size and type, and detection
#probability is a function of sky and time (5 points).
fit <- pcount(formula = ~ time + sky ~ size + type,
data = nmix_data, K = 100)
fit
#2. Write a function that calculates the sum of squared Pearson residuals from a fitted model. This test
#statistic can be calculated as:
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
y <- read.csv('sosp_nmix (2).csv')
head(y)
y <- read.csv('sosp_nmix (2).csv')
head(y)
library(unmarked)
# converting count data into a matrix
# matrix format required by unmarkedFramePCount
sosp_mat <- as.matrix(y)
nmix_data <- unmarkedFramePCount(y = sosp_mat)
det_covs <- read.csv('p_covs_nmix (2).csv')
head(det_covs)
det_covs <- list(
time = data.frame(p_covs[, c('time.1', 'time.2')]),
sky = data.frame(sky.1 = factor(p_covs$sky.1),
sky.2 = factor(p_covs$sky.2))
)
site_covs <- read.csv('n_covs_nmix (2).csv')
head(site_covs)
site_covs$type <- factor(site_covs$type)
nmix_data <- unmarkedFramePCount(y = sosp_mat, # detection / non-detection
siteCovs = site_covs, # site-level covs
obsCovs = det_covs)
fit <- pcount(formula = ~ time + sky ~ size + type,
data = nmix_data, K = 100)
fit
#2. Write a function that calculates the sum of squared Pearson residuals from a fitted model. This test
#statistic can be calculated as:
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
y <- read.csv('sosp_nmix (2).csv')
head(y)
y <- read.csv('sosp_nmix (2).csv')
head(y)
library(unmarked)
# converting count data into a matrix
# matrix format required by unmarkedFramePCount
sosp_mat <- as.matrix(y)
nmix_data <- unmarkedFramePCount(y = sosp_mat)
det_covs <- read.csv('p_covs_nmix (2).csv')
head(det_covs)
det_covs <- list(
time = data.frame(p_covs[, c('time.1', 'time.2')]),
sky = data.frame(sky.1 = factor(p_covs$sky.1),
sky.2 = factor(p_covs$sky.2))
)
site_covs <- read.csv('n_covs_nmix (2).csv')
head(site_covs)
site_covs$type <- factor(site_covs$type)
nmix_data <- unmarkedFramePCount(y = sosp_mat, # detection / non-detection
siteCovs = site_covs, # site-level covs
obsCovs = det_covs)
fit <- pcount(formula = ~ time + sky ~ size + type,
data = nmix_data, K = 100)
fit
#2. Write a function that calculates the sum of squared Pearson residuals from a fitted model. This test
#statistic can be calculated as:
mod <- fit
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- as.matrix(det$Predicted, byrow = TRUE)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - det$Predicted))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
as.matrix(det$Predicted, byrow = TRUE)
det$Predicted
predict(mod, type = "det")
det$Predicted
View(det)
str(det)
as.matrix(det, byrow = TRUE)
detm <- as.matrix(det, byrow = TRUE)
View(detm)
detm <- matrix(det, byrow = TRUE)
View(detm)
detm <- matrix(det, byrow = TRUE, nrow= 2)
detm
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- matrix(det, byrow = TRUE, nrow= 2)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - detm))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
mod <- fit
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- matrix(det, byrow = TRUE, nrow= 2)
View(detm)
View(detm)
detm <- as.matrix(det, byrow = TRUE, nrow= 2)
View(detm)
detm <- as.matrix(det$Predicted, byrow = TRUE, nrow= 2)
View(detm)
detm <- matrix(det$Predicted, byrow = TRUE, nrow= 2)
View(detm)
detm <- matrix(det$Predicted, byrow = TRUE, ncol = 2)
View(detm)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - detm))
return(sum(ts))
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- matrix(det$Predicted, byrow = TRUE, ncol = 2)
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - detm))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
detm <- matrix(det$Predicted, byrow = TRUE, ncol = 2) #
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - detm))
return(sum(ts))
pear <- function(mod){ # mod is fitted model
obs <- getY(mod@data) # observed count
ex <- fitted(mod) #obs prob * expected count
#exabun <- predict(mod, type = "state")
det <- predict(mod, type = "det")
detm <- matrix(det$Predicted, byrow = TRUE, ncol = 2) #
ts <- (obs - (ex)) ^ 2 / # chi-square statistic
((ex) * (1 - detm))
return(sum(ts))
}
pear(fit)  # 1025.856 expected value
exP <- exabun$Predicted*det$Predicted
sims <- parboot(fit, pear, nsim = 1000)
sims
plot(sims)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
plot(sims)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5)
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
plot(sims)
hist(sims@t.star[, 1], xlab = 'Pearson Residuals',
main = 'distribution of test statistic',
cex.axis = 1.5, cex.lab = 1.5, cex.main = 1.5, xlim= c(0,1000))
lines(x = rep(pear(fit), 2),
y = c(0, 1000),
col = 'red', lwd = 3)
sum(sims@t.star[, 1] > pear(fit)) / 1000
